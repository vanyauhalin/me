import child from "node:child_process"
import util from "node:util"
import browserslist from "browserslist"
import * as htmlMinifierTerser from "html-minifier-terser"
import * as lightningcss from "lightningcss"

const exec = util.promisify(child.exec)

export const config = {
	dir: {
		includes: "../_includes",
		input: "pages",
		layouts: "../_layouts",
	},
	markdownTemplateEngine: "njk",
	templateFormats: [
		"md",
		"njk",
	],
}

/**
 * @param {any} uc
 */
export default function(uc) {
	uc.addPlugin(mode)
	uc.addPlugin(terser)
	uc.addPlugin(styles)
	uc.addPlugin(posts)
	uc.addPlugin(domain)
	uc.addPlugin(moondust)
}

/**
 * @returns {boolean}
 */
function isBuild() {
	return process.env.ELEVENTY_RUN_MODE === "build"
}

/**
 * @param {any} uc
 */
function mode(uc) {
	uc.addGlobalData("isBuild", isBuild)
}

/**
 * @param {any} uc
 */
function terser(uc) {
	if (!isBuild()) {
		return
	}

	uc.addTransform(
		"html-minifier-terser",

		/**
		 * @param {string} c
		 * @param {string} f
		 * @returns {Promise<string>}
		 */
		async(c, f) => {
			try {
				if (f.endsWith(".html") || f.endsWith(".xml")) {
					return await htmlMinifierTerser.minify(c, {
						collapseWhitespace: true,
						decodeEntities: true,
						includeAutoGeneratedTags: false,
						removeAttributeQuotes: true,
						removeComments: true,
						removeEmptyAttributes: true,
						removeRedundantAttributes: true,
						sortAttributes: true,
					})
				}
				return c
			} catch (/** @type {any} */ err) {
				if (isBuild()) {
					throw err
				}
				uc.logger.error(err.message)
				return ""
			}
		},
	)
}

/**
 * @param {any} uc
 */
function styles(uc) {
	let bl = browserslist("> 0.2% and not dead")
	let lt = lightningcss.browserslistToTargets(bl)

	uc.addWatchTarget("_assets/main.css")
	uc.addGlobalData(
		"styles",

		/**
		 * @returns {Promise<string>}
		 */
		async() => {
			try {
				let r = await lightningcss.bundleAsync({
					drafts: {
						customMedia: true,
					},
					filename: "_assets/main.css",
					minify: isBuild(),
					targets: lt,
				})

				if (r.warnings.length !== 0) {
					for (let w of r.warnings) {
						uc.logger.warn(w.message)
					}
				}

				return String(r.code)
			} catch (/** @type {any} */ err) {
				if (isBuild()) {
					throw err
				}
				uc.logger.error(err.message)
				return ""
			}
		},
	)
}

/**
 * @param {any} uc
 */
function posts(uc) {
	uc.addCollection(
		"posts",

		/**
		 * @param {any} c
		 * @returns {any}
		 */
		(c) => {
			return c.getFilteredByGlob("pages/posts/*/index.md")
		},
	)
}

/**
 * @param {any} uc
 */
function domain(uc) {
	uc.addGlobalData(
		"domain",

		/**
		 * @returns {string}
		 */
		() => {
			return "https://vanyauhalin.me"
		},
	)
}

/**
 * @typedef {object} Moondust
 * @property {number} stars
 * @property {number} installs
 */

/**
 * @param {any} uc
 */
function moondust(uc) {
	/** @type {Moondust | undefined} */
	let moondust

	uc.addGlobalData(
		"moondust",

		/**
		 * @returns {Promise<Moondust>}
		 */
		async() => {
			try {
				if (!moondust) {
					moondust = {
						stars: await ghStars(),
						installs: await vsceInstalls() + await ovsxInstalls(),
					}
				}
				return moondust
			} catch (/** @type {any} */ err) {
				if (isBuild()) {
					throw err
				}
				uc.logger.error(err.message)
				return {
					stars: 0,
					installs: 0,
				}
			}
		},
	)

	/**
	 * @returns {Promise<number>}
	 */
	async function ghStars() {
		let o = await json("gh repo view --json stargazerCount vanyauhalin/moondusttheme")
		return o.stargazerCount
	}

	/**
	 * @returns {Promise<number>}
	 */
	async function vsceInstalls() {
		let n = 0
		let o = await json("vsce show --json vanyauhalin.moondusttheme")
		for (let s of o.statistics) {
			if (s.statisticName === "install") {
				n += s.value
				break
			}
		}
		return n
	}

	/**
	 * @returns {Promise<number>}
	 */
	async function ovsxInstalls() {
		let o = await json("ovsx get --metadata vanyauhalin.moondusttheme")
		return o.downloadCount
	}

	/**
	 * @param {string} cmd
	 * @returns {Promise<any>}
	 */
	async function json(cmd) {
		let c = await exec(`command ${cmd}`)
		if (c.stderr) {
			throw new Error(String(c.stderr))
		}
		return JSON.parse(String(c.stdout))
	}
}
